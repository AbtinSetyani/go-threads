// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: threads.proto

package threads_pb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	pb "github.com/textileio/go-textile/pb"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type NodeIndex_Type int32

const (
	NodeIndex_INVITE NodeIndex_Type = 0
	NodeIndex_JOIN   NodeIndex_Type = 1
	NodeIndex_LEAVE  NodeIndex_Type = 2
	NodeIndex_WRITE  NodeIndex_Type = 3
	NodeIndex_REACT  NodeIndex_Type = 4
	NodeIndex_REMOVE NodeIndex_Type = 5
)

var NodeIndex_Type_name = map[int32]string{
	0: "INVITE",
	1: "JOIN",
	2: "LEAVE",
	3: "WRITE",
	4: "REACT",
	5: "REMOVE",
}

var NodeIndex_Type_value = map[string]int32{
	"INVITE": 0,
	"JOIN":   1,
	"LEAVE":  2,
	"WRITE":  3,
	"REACT":  4,
	"REMOVE": 5,
}

func (x NodeIndex_Type) String() string {
	return proto.EnumName(NodeIndex_Type_name, int32(x))
}

func (NodeIndex_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{2, 0}
}

type NodeIndex_Status int32

const (
	NodeIndex_READY   NodeIndex_Status = 0
	NodeIndex_QUEUED  NodeIndex_Status = 1
	NodeIndex_PENDING NodeIndex_Status = 2
)

var NodeIndex_Status_name = map[int32]string{
	0: "READY",
	1: "QUEUED",
	2: "PENDING",
}

var NodeIndex_Status_value = map[string]int32{
	"READY":   0,
	"QUEUED":  1,
	"PENDING": 2,
}

func (x NodeIndex_Status) String() string {
	return proto.EnumName(NodeIndex_Status_name, int32(x))
}

func (NodeIndex_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{2, 1}
}

type Roles_Role int32

const (
	Roles_NO_ACCESS Roles_Role = 0
	Roles_READ      Roles_Role = 1
	Roles_ANNOTATE  Roles_Role = 2
	Roles_WRITE     Roles_Role = 3
)

var Roles_Role_name = map[int32]string{
	0: "NO_ACCESS",
	1: "READ",
	2: "ANNOTATE",
	3: "WRITE",
}

var Roles_Role_value = map[string]int32{
	"NO_ACCESS": 0,
	"READ":      1,
	"ANNOTATE":  2,
	"WRITE":     3,
}

func (x Roles_Role) String() string {
	return proto.EnumName(Roles_Role_name, int32(x))
}

func (Roles_Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{4, 0}
}

type Index struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Key   []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Heads string `protobuf:"bytes,4,opt,name=heads,proto3" json:"heads,omitempty"`
}

func (m *Index) Reset()         { *m = Index{} }
func (m *Index) String() string { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()    {}
func (*Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{0}
}
func (m *Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Index.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Index.Merge(m, src)
}
func (m *Index) XXX_Size() int {
	return m.Size()
}
func (m *Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Index proto.InternalMessageInfo

func (m *Index) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Index) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Index) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Index) GetHeads() string {
	if m != nil {
		return m.Heads
	}
	return ""
}

type Indexes struct {
	Items []*Index `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *Indexes) Reset()         { *m = Indexes{} }
func (m *Indexes) String() string { return proto.CompactTextString(m) }
func (*Indexes) ProtoMessage()    {}
func (*Indexes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{1}
}
func (m *Indexes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Indexes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Indexes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Indexes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Indexes.Merge(m, src)
}
func (m *Indexes) XXX_Size() int {
	return m.Size()
}
func (m *Indexes) XXX_DiscardUnknown() {
	xxx_messageInfo_Indexes.DiscardUnknown(m)
}

var xxx_messageInfo_Indexes proto.InternalMessageInfo

func (m *Indexes) GetItems() []*Index {
	if m != nil {
		return m.Items
	}
	return nil
}

type NodeIndex struct {
	Id       string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Thread   string           `protobuf:"bytes,2,opt,name=thread,proto3" json:"thread,omitempty"`
	Author   string           `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	Type     NodeIndex_Type   `protobuf:"varint,4,opt,name=type,proto3,enum=threads.pb.NodeIndex_Type" json:"type,omitempty"`
	Date     *types.Timestamp `protobuf:"bytes,5,opt,name=date,proto3" json:"date,omitempty"`
	Parents  []string         `protobuf:"bytes,6,rep,name=parents,proto3" json:"parents,omitempty"`
	Target   string           `protobuf:"bytes,7,opt,name=target,proto3" json:"target,omitempty"`
	Data     string           `protobuf:"bytes,8,opt,name=data,proto3" json:"data,omitempty"`
	Status   NodeIndex_Status `protobuf:"varint,9,opt,name=status,proto3,enum=threads.pb.NodeIndex_Status" json:"status,omitempty"`
	Attempts int32            `protobuf:"varint,10,opt,name=attempts,proto3" json:"attempts,omitempty"`
}

func (m *NodeIndex) Reset()         { *m = NodeIndex{} }
func (m *NodeIndex) String() string { return proto.CompactTextString(m) }
func (*NodeIndex) ProtoMessage()    {}
func (*NodeIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{2}
}
func (m *NodeIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeIndex.Merge(m, src)
}
func (m *NodeIndex) XXX_Size() int {
	return m.Size()
}
func (m *NodeIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeIndex.DiscardUnknown(m)
}

var xxx_messageInfo_NodeIndex proto.InternalMessageInfo

func (m *NodeIndex) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeIndex) GetThread() string {
	if m != nil {
		return m.Thread
	}
	return ""
}

func (m *NodeIndex) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *NodeIndex) GetType() NodeIndex_Type {
	if m != nil {
		return m.Type
	}
	return NodeIndex_INVITE
}

func (m *NodeIndex) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

func (m *NodeIndex) GetParents() []string {
	if m != nil {
		return m.Parents
	}
	return nil
}

func (m *NodeIndex) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *NodeIndex) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *NodeIndex) GetStatus() NodeIndex_Status {
	if m != nil {
		return m.Status
	}
	return NodeIndex_READY
}

func (m *NodeIndex) GetAttempts() int32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

type NodeIndexes struct {
	Items []*NodeIndex `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *NodeIndexes) Reset()         { *m = NodeIndexes{} }
func (m *NodeIndexes) String() string { return proto.CompactTextString(m) }
func (*NodeIndexes) ProtoMessage()    {}
func (*NodeIndexes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{3}
}
func (m *NodeIndexes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeIndexes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeIndexes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeIndexes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeIndexes.Merge(m, src)
}
func (m *NodeIndexes) XXX_Size() int {
	return m.Size()
}
func (m *NodeIndexes) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeIndexes.DiscardUnknown(m)
}

var xxx_messageInfo_NodeIndexes proto.InternalMessageInfo

func (m *NodeIndexes) GetItems() []*NodeIndex {
	if m != nil {
		return m.Items
	}
	return nil
}

type Roles struct {
	Default  Roles_Role            `protobuf:"varint,1,opt,name=default,proto3,enum=threads.pb.Roles_Role" json:"default,omitempty"`
	Accounts map[string]Roles_Role `protobuf:"bytes,2,rep,name=accounts,proto3" json:"accounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=threads.pb.Roles_Role"`
}

func (m *Roles) Reset()         { *m = Roles{} }
func (m *Roles) String() string { return proto.CompactTextString(m) }
func (*Roles) ProtoMessage()    {}
func (*Roles) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{4}
}
func (m *Roles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Roles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Roles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Roles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Roles.Merge(m, src)
}
func (m *Roles) XXX_Size() int {
	return m.Size()
}
func (m *Roles) XXX_DiscardUnknown() {
	xxx_messageInfo_Roles.DiscardUnknown(m)
}

var xxx_messageInfo_Roles proto.InternalMessageInfo

func (m *Roles) GetDefault() Roles_Role {
	if m != nil {
		return m.Default
	}
	return Roles_NO_ACCESS
}

func (m *Roles) GetAccounts() map[string]Roles_Role {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type Member struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Thread   string `protobuf:"bytes,2,opt,name=thread,proto3" json:"thread,omitempty"`
	Welcomed bool   `protobuf:"varint,3,opt,name=welcomed,proto3" json:"welcomed,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{5}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Member) GetThread() string {
	if m != nil {
		return m.Thread
	}
	return ""
}

func (m *Member) GetWelcomed() bool {
	if m != nil {
		return m.Welcomed
	}
	return false
}

type SchemaNode struct {
	Name       string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Pin        bool                   `protobuf:"varint,2,opt,name=pin,proto3" json:"pin,omitempty"`
	Plaintext  bool                   `protobuf:"varint,3,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	Mill       string                 `protobuf:"bytes,4,opt,name=mill,proto3" json:"mill,omitempty"`
	Opts       map[string]string      `protobuf:"bytes,5,rep,name=opts,proto3" json:"opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	JsonSchema *types.Struct          `protobuf:"bytes,6,opt,name=json_schema,json=jsonSchema,proto3" json:"json_schema,omitempty"`
	Links      map[string]*SchemaLink `protobuf:"bytes,7,rep,name=links,proto3" json:"links,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SchemaNode) Reset()         { *m = SchemaNode{} }
func (m *SchemaNode) String() string { return proto.CompactTextString(m) }
func (*SchemaNode) ProtoMessage()    {}
func (*SchemaNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{6}
}
func (m *SchemaNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaNode.Merge(m, src)
}
func (m *SchemaNode) XXX_Size() int {
	return m.Size()
}
func (m *SchemaNode) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaNode.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaNode proto.InternalMessageInfo

func (m *SchemaNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaNode) GetPin() bool {
	if m != nil {
		return m.Pin
	}
	return false
}

func (m *SchemaNode) GetPlaintext() bool {
	if m != nil {
		return m.Plaintext
	}
	return false
}

func (m *SchemaNode) GetMill() string {
	if m != nil {
		return m.Mill
	}
	return ""
}

func (m *SchemaNode) GetOpts() map[string]string {
	if m != nil {
		return m.Opts
	}
	return nil
}

func (m *SchemaNode) GetJsonSchema() *types.Struct {
	if m != nil {
		return m.JsonSchema
	}
	return nil
}

func (m *SchemaNode) GetLinks() map[string]*SchemaLink {
	if m != nil {
		return m.Links
	}
	return nil
}

type SchemaLink struct {
	Use        string            `protobuf:"bytes,1,opt,name=use,proto3" json:"use,omitempty"`
	Pin        bool              `protobuf:"varint,2,opt,name=pin,proto3" json:"pin,omitempty"`
	Plaintext  bool              `protobuf:"varint,3,opt,name=plaintext,proto3" json:"plaintext,omitempty"`
	Mill       string            `protobuf:"bytes,4,opt,name=mill,proto3" json:"mill,omitempty"`
	Opts       map[string]string `protobuf:"bytes,5,rep,name=opts,proto3" json:"opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	JsonSchema *types.Struct     `protobuf:"bytes,6,opt,name=json_schema,json=jsonSchema,proto3" json:"json_schema,omitempty"`
}

func (m *SchemaLink) Reset()         { *m = SchemaLink{} }
func (m *SchemaLink) String() string { return proto.CompactTextString(m) }
func (*SchemaLink) ProtoMessage()    {}
func (*SchemaLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{7}
}
func (m *SchemaLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaLink.Merge(m, src)
}
func (m *SchemaLink) XXX_Size() int {
	return m.Size()
}
func (m *SchemaLink) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaLink.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaLink proto.InternalMessageInfo

func (m *SchemaLink) GetUse() string {
	if m != nil {
		return m.Use
	}
	return ""
}

func (m *SchemaLink) GetPin() bool {
	if m != nil {
		return m.Pin
	}
	return false
}

func (m *SchemaLink) GetPlaintext() bool {
	if m != nil {
		return m.Plaintext
	}
	return false
}

func (m *SchemaLink) GetMill() string {
	if m != nil {
		return m.Mill
	}
	return ""
}

func (m *SchemaLink) GetOpts() map[string]string {
	if m != nil {
		return m.Opts
	}
	return nil
}

func (m *SchemaLink) GetJsonSchema() *types.Struct {
	if m != nil {
		return m.JsonSchema
	}
	return nil
}

type NodeMessage struct {
	Id   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Peer string           `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer,omitempty"`
	Env  *pb.Envelope     `protobuf:"bytes,3,opt,name=env,proto3" json:"env,omitempty"`
	Date *types.Timestamp `protobuf:"bytes,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *NodeMessage) Reset()         { *m = NodeMessage{} }
func (m *NodeMessage) String() string { return proto.CompactTextString(m) }
func (*NodeMessage) ProtoMessage()    {}
func (*NodeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f2ba358bb2150022, []int{8}
}
func (m *NodeMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMessage.Merge(m, src)
}
func (m *NodeMessage) XXX_Size() int {
	return m.Size()
}
func (m *NodeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMessage proto.InternalMessageInfo

func (m *NodeMessage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeMessage) GetPeer() string {
	if m != nil {
		return m.Peer
	}
	return ""
}

func (m *NodeMessage) GetEnv() *pb.Envelope {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *NodeMessage) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

func init() {
	proto.RegisterEnum("threads.pb.NodeIndex_Type", NodeIndex_Type_name, NodeIndex_Type_value)
	proto.RegisterEnum("threads.pb.NodeIndex_Status", NodeIndex_Status_name, NodeIndex_Status_value)
	proto.RegisterEnum("threads.pb.Roles_Role", Roles_Role_name, Roles_Role_value)
	proto.RegisterType((*Index)(nil), "threads.pb.Index")
	proto.RegisterType((*Indexes)(nil), "threads.pb.Indexes")
	proto.RegisterType((*NodeIndex)(nil), "threads.pb.NodeIndex")
	proto.RegisterType((*NodeIndexes)(nil), "threads.pb.NodeIndexes")
	proto.RegisterType((*Roles)(nil), "threads.pb.Roles")
	proto.RegisterMapType((map[string]Roles_Role)(nil), "threads.pb.Roles.AccountsEntry")
	proto.RegisterType((*Member)(nil), "threads.pb.Member")
	proto.RegisterType((*SchemaNode)(nil), "threads.pb.SchemaNode")
	proto.RegisterMapType((map[string]*SchemaLink)(nil), "threads.pb.SchemaNode.LinksEntry")
	proto.RegisterMapType((map[string]string)(nil), "threads.pb.SchemaNode.OptsEntry")
	proto.RegisterType((*SchemaLink)(nil), "threads.pb.SchemaLink")
	proto.RegisterMapType((map[string]string)(nil), "threads.pb.SchemaLink.OptsEntry")
	proto.RegisterType((*NodeMessage)(nil), "threads.pb.NodeMessage")
}

func init() { proto.RegisterFile("threads.proto", fileDescriptor_f2ba358bb2150022) }

var fileDescriptor_f2ba358bb2150022 = []byte{
	// 899 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcf, 0x8f, 0xdb, 0x44,
	0x14, 0x8e, 0x7f, 0x25, 0xf1, 0x4b, 0x77, 0x65, 0x46, 0xa5, 0x58, 0x66, 0x95, 0x06, 0x5f, 0x88,
	0x44, 0xeb, 0x54, 0xa1, 0x52, 0x57, 0xe5, 0x14, 0x76, 0x2d, 0x14, 0xb4, 0x9b, 0x94, 0x49, 0xba,
	0x88, 0x53, 0xe5, 0xc4, 0xd3, 0xc4, 0xd4, 0xbf, 0x64, 0x8f, 0x97, 0xee, 0x85, 0x1b, 0x27, 0x2e,
	0x1c, 0xf9, 0x63, 0x38, 0x70, 0xe4, 0xd8, 0x23, 0x47, 0xd8, 0xfd, 0x27, 0x38, 0xa2, 0x99, 0xb1,
	0x9d, 0x2c, 0x9b, 0x8a, 0x15, 0x42, 0xbd, 0x44, 0xef, 0xcd, 0x7c, 0xef, 0xbd, 0xcf, 0xef, 0x7b,
	0x6f, 0x02, 0x7b, 0x74, 0x9d, 0x11, 0xcf, 0xcf, 0x9d, 0x34, 0x4b, 0x68, 0x82, 0xa0, 0x76, 0x17,
	0xd6, 0xfd, 0x55, 0x92, 0xac, 0x42, 0x32, 0xe0, 0x37, 0x8b, 0xe2, 0xe5, 0x80, 0x06, 0x11, 0xc9,
	0xa9, 0x17, 0xa5, 0x02, 0x6c, 0x1d, 0xfc, 0x13, 0x90, 0xd3, 0xac, 0x58, 0xd2, 0xf2, 0xf6, 0xe1,
	0x2a, 0xa0, 0xeb, 0x62, 0xe1, 0x2c, 0x93, 0x68, 0xb0, 0x4a, 0x56, 0xc9, 0x06, 0xc6, 0x3c, 0xee,
	0x70, 0xab, 0x84, 0x3f, 0xda, 0x82, 0x53, 0xf2, 0x9a, 0x06, 0x21, 0x09, 0x18, 0xe0, 0x61, 0xe9,
	0x0c, 0xd2, 0xc5, 0x20, 0x22, 0x79, 0xee, 0xad, 0x88, 0x88, 0xb0, 0x67, 0xa0, 0x8d, 0x63, 0x9f,
	0xbc, 0x46, 0xfb, 0x20, 0x07, 0xbe, 0x29, 0xf5, 0xa4, 0xbe, 0x8e, 0xe5, 0xc0, 0x47, 0x06, 0x28,
	0xaf, 0xc8, 0x85, 0x29, 0xf7, 0xa4, 0xfe, 0x1d, 0xcc, 0x4c, 0x84, 0x40, 0x8d, 0xbd, 0x88, 0x98,
	0x0a, 0xc7, 0x70, 0x1b, 0xdd, 0x05, 0x6d, 0xcd, 0x3e, 0xd5, 0x54, 0xf9, 0xa1, 0x70, 0xec, 0x21,
	0xb4, 0x78, 0x52, 0x92, 0xa3, 0x8f, 0x41, 0x0b, 0x28, 0x89, 0x72, 0x53, 0xea, 0x29, 0xfd, 0xce,
	0xf0, 0x3d, 0x67, 0xd3, 0x1b, 0x87, 0x63, 0xb0, 0xb8, 0xb7, 0x7f, 0x51, 0x40, 0x9f, 0x24, 0x3e,
	0xd9, 0xcd, 0xe6, 0x1e, 0x34, 0x45, 0x20, 0x27, 0xa4, 0xe3, 0xd2, 0x63, 0xe7, 0x5e, 0x41, 0xd7,
	0x49, 0x56, 0xb2, 0x2a, 0x3d, 0xe4, 0x80, 0x4a, 0x2f, 0x52, 0xc2, 0x69, 0xed, 0x0f, 0xad, 0xed,
	0xaa, 0x75, 0x11, 0x67, 0x7e, 0x91, 0x12, 0xcc, 0x71, 0x0c, 0xef, 0x7b, 0x94, 0x98, 0x5a, 0x4f,
	0xea, 0x77, 0x86, 0x96, 0x23, 0x44, 0x71, 0xaa, 0x6e, 0x3b, 0xf3, 0x4a, 0x35, 0xcc, 0x71, 0xc8,
	0x84, 0x56, 0xea, 0x65, 0x24, 0xa6, 0xb9, 0xd9, 0xec, 0x29, 0x7d, 0x1d, 0x57, 0x2e, 0x67, 0xea,
	0x65, 0x2b, 0x42, 0xcd, 0x56, 0xc9, 0x94, 0x7b, 0xac, 0x7b, 0xbe, 0x47, 0x3d, 0xb3, 0x2d, 0xba,
	0xc7, 0x6c, 0xf4, 0x18, 0x9a, 0x39, 0xf5, 0x68, 0x91, 0x9b, 0x3a, 0xe7, 0x79, 0xb0, 0x9b, 0xe7,
	0x8c, 0x63, 0x70, 0x89, 0x45, 0x16, 0xb4, 0x3d, 0x4a, 0x49, 0x94, 0xd2, 0xdc, 0x84, 0x9e, 0xd4,
	0xd7, 0x70, 0xed, 0xdb, 0x63, 0x50, 0xd9, 0x57, 0x21, 0x80, 0xe6, 0x78, 0x72, 0x36, 0x9e, 0xbb,
	0x46, 0x03, 0xb5, 0x41, 0xfd, 0x72, 0x3a, 0x9e, 0x18, 0x12, 0xd2, 0x41, 0x3b, 0x71, 0x47, 0x67,
	0xae, 0x21, 0x33, 0xf3, 0x6b, 0xcc, 0xee, 0x15, 0x66, 0x62, 0x77, 0x74, 0x34, 0x37, 0x54, 0x16,
	0x86, 0xdd, 0xd3, 0xe9, 0x99, 0x6b, 0x68, 0xf6, 0x03, 0x68, 0x8a, 0xc2, 0x25, 0xe0, 0xf8, 0x1b,
	0xa3, 0xc1, 0x00, 0x5f, 0x3d, 0x77, 0x9f, 0xbb, 0xc7, 0x86, 0x84, 0x3a, 0xd0, 0x7a, 0xe6, 0x4e,
	0x8e, 0xc7, 0x93, 0x2f, 0x0c, 0xd9, 0x7e, 0x0a, 0x9d, 0x9a, 0x30, 0xc9, 0xd1, 0x27, 0xd7, 0x65,
	0x7f, 0x7f, 0xe7, 0x87, 0x55, 0xd2, 0xff, 0x20, 0x83, 0x86, 0x93, 0x90, 0xe4, 0xe8, 0x11, 0xb4,
	0x7c, 0xf2, 0xd2, 0x2b, 0x42, 0xca, 0xb5, 0xdf, 0x1f, 0xde, 0xdb, 0x0e, 0xe4, 0x18, 0xfe, 0x8b,
	0x2b, 0x18, 0xfa, 0x0c, 0xda, 0xde, 0x72, 0x99, 0x14, 0x4c, 0x09, 0x99, 0xd7, 0xba, 0x7f, 0x33,
	0x64, 0x54, 0x22, 0xdc, 0x98, 0x66, 0x17, 0xb8, 0x0e, 0xb0, 0x66, 0xb0, 0x77, 0xed, 0xaa, 0x1a,
	0x7a, 0x31, 0x77, 0x7c, 0xe8, 0x1f, 0x80, 0x76, 0xee, 0x85, 0x05, 0xe1, 0x73, 0xf7, 0x76, 0x3e,
	0x02, 0xf4, 0x54, 0x3e, 0x94, 0xec, 0x43, 0x50, 0xd9, 0x11, 0xda, 0x03, 0x7d, 0x32, 0x7d, 0x31,
	0x3a, 0x3a, 0x72, 0x67, 0x33, 0xa1, 0x02, 0x6b, 0xa2, 0x21, 0xa1, 0x3b, 0xd0, 0x1e, 0x4d, 0x26,
	0xd3, 0xf9, 0x68, 0x7e, 0x5d, 0x08, 0xfb, 0x04, 0x9a, 0xa7, 0x24, 0x5a, 0x90, 0xec, 0xd6, 0xe3,
	0x6f, 0x41, 0xfb, 0x3b, 0x12, 0x2e, 0x93, 0x88, 0xf8, 0x7c, 0x01, 0xda, 0xb8, 0xf6, 0xed, 0x9f,
	0x15, 0x80, 0xd9, 0x72, 0x4d, 0x22, 0x8f, 0x35, 0xbc, 0xde, 0x5e, 0x69, 0x6b, 0x7b, 0x0d, 0x50,
	0xd2, 0x20, 0xe6, 0x39, 0xdb, 0x98, 0x99, 0xe8, 0x00, 0xf4, 0x34, 0xf4, 0x82, 0x98, 0xbd, 0x17,
	0x65, 0xc6, 0xcd, 0x01, 0xcb, 0x11, 0x05, 0x61, 0x58, 0x2e, 0x3b, 0xb7, 0xd1, 0x63, 0x50, 0x13,
	0x36, 0x89, 0x1a, 0x6f, 0x7e, 0x6f, 0xbb, 0x3f, 0x9b, 0xea, 0xce, 0x34, 0xad, 0xba, 0xcf, 0xd1,
	0xe8, 0x10, 0x3a, 0xdf, 0xe6, 0x49, 0xfc, 0x22, 0xe7, 0x10, 0xb3, 0xc9, 0xd7, 0xee, 0x83, 0x1b,
	0x6b, 0x37, 0xe3, 0x6f, 0x21, 0x06, 0x86, 0x15, 0xd9, 0xd0, 0x13, 0xd0, 0xc2, 0x20, 0x7e, 0x95,
	0x9b, 0x2d, 0x5e, 0xf0, 0xa3, 0xb7, 0x14, 0x3c, 0x61, 0x18, 0x51, 0x51, 0xe0, 0xad, 0x27, 0xa0,
	0xd7, 0x2c, 0x76, 0x08, 0x7d, 0x77, 0x5b, 0x68, 0x7d, 0x4b, 0x50, 0xeb, 0x19, 0xc0, 0x26, 0xdb,
	0xbf, 0x8d, 0x48, 0xe7, 0xfa, 0x88, 0x08, 0x46, 0x2c, 0x7c, 0x7b, 0x44, 0x7e, 0x94, 0x2b, 0x69,
	0xd8, 0x0d, 0x4b, 0x59, 0xe4, 0x95, 0x32, 0xcc, 0x7c, 0x37, 0xc2, 0xb0, 0xda, 0xff, 0x9f, 0x30,
	0xff, 0xb9, 0xbf, 0xf6, 0xf7, 0xe2, 0xe9, 0x38, 0x15, 0xff, 0x4b, 0x37, 0x66, 0x1f, 0x81, 0x9a,
	0x12, 0x92, 0x95, 0x71, 0xdc, 0x46, 0x1f, 0x82, 0x42, 0xe2, 0x73, 0xde, 0x87, 0xce, 0x50, 0x77,
	0xdc, 0xf8, 0x9c, 0x84, 0x49, 0x4a, 0x30, 0x3b, 0xad, 0xdf, 0x72, 0xf5, 0x76, 0x6f, 0xf9, 0xe7,
	0xbd, 0xbf, 0xfe, 0xec, 0x4a, 0xbf, 0x5e, 0x76, 0xa5, 0xdf, 0x2e, 0xbb, 0xd2, 0x9b, 0xcb, 0xae,
	0xf4, 0xc7, 0x65, 0x57, 0xfa, 0xe9, 0xaa, 0xdb, 0x78, 0x73, 0xd5, 0x6d, 0xfc, 0x7e, 0xd5, 0x6d,
	0x2c, 0x9a, 0x3c, 0xf6, 0xd3, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xab, 0x6c, 0x94, 0x94, 0xe8,
	0x07, 0x00, 0x00,
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Heads) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Heads)))
		i += copy(dAtA[i:], m.Heads)
	}
	return i, nil
}

func (m *Indexes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Indexes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintThreads(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Thread) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Thread)))
		i += copy(dAtA[i:], m.Thread)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Type))
	}
	if m.Date != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Date.Size()))
		n1, err := m.Date.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Parents) > 0 {
		for _, s := range m.Parents {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Status != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Status))
	}
	if m.Attempts != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Attempts))
	}
	return i, nil
}

func (m *NodeIndexes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeIndexes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintThreads(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Roles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Roles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Default != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Default))
	}
	if len(m.Accounts) > 0 {
		for k, _ := range m.Accounts {
			dAtA[i] = 0x12
			i++
			v := m.Accounts[k]
			mapSize := 1 + len(k) + sovThreads(uint64(len(k))) + 1 + sovThreads(uint64(v))
			i = encodeVarintThreads(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintThreads(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintThreads(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Thread) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Thread)))
		i += copy(dAtA[i:], m.Thread)
	}
	if m.Welcomed {
		dAtA[i] = 0x18
		i++
		if m.Welcomed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SchemaNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Pin {
		dAtA[i] = 0x10
		i++
		if m.Pin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Plaintext {
		dAtA[i] = 0x18
		i++
		if m.Plaintext {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Mill) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Mill)))
		i += copy(dAtA[i:], m.Mill)
	}
	if len(m.Opts) > 0 {
		for k, _ := range m.Opts {
			dAtA[i] = 0x2a
			i++
			v := m.Opts[k]
			mapSize := 1 + len(k) + sovThreads(uint64(len(k))) + 1 + len(v) + sovThreads(uint64(len(v)))
			i = encodeVarintThreads(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintThreads(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintThreads(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.JsonSchema != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.JsonSchema.Size()))
		n2, err := m.JsonSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Links) > 0 {
		for k, _ := range m.Links {
			dAtA[i] = 0x3a
			i++
			v := m.Links[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovThreads(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovThreads(uint64(len(k))) + msgSize
			i = encodeVarintThreads(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintThreads(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintThreads(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *SchemaLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Use) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Use)))
		i += copy(dAtA[i:], m.Use)
	}
	if m.Pin {
		dAtA[i] = 0x10
		i++
		if m.Pin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Plaintext {
		dAtA[i] = 0x18
		i++
		if m.Plaintext {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Mill) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Mill)))
		i += copy(dAtA[i:], m.Mill)
	}
	if len(m.Opts) > 0 {
		for k, _ := range m.Opts {
			dAtA[i] = 0x2a
			i++
			v := m.Opts[k]
			mapSize := 1 + len(k) + sovThreads(uint64(len(k))) + 1 + len(v) + sovThreads(uint64(len(v)))
			i = encodeVarintThreads(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintThreads(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintThreads(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.JsonSchema != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.JsonSchema.Size()))
		n4, err := m.JsonSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *NodeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Peer) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintThreads(dAtA, i, uint64(len(m.Peer)))
		i += copy(dAtA[i:], m.Peer)
	}
	if m.Env != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Env.Size()))
		n5, err := m.Env.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Date != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintThreads(dAtA, i, uint64(m.Date.Size()))
		n6, err := m.Date.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func encodeVarintThreads(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedIndex(r randyThreads, easy bool) *Index {
	this := &Index{}
	this.Id = string(randStringThreads(r))
	v1 := r.Intn(100)
	this.Key = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	this.Name = string(randStringThreads(r))
	this.Heads = string(randStringThreads(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIndexes(r randyThreads, easy bool) *Indexes {
	this := &Indexes{}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Items = make([]*Index, v2)
		for i := 0; i < v2; i++ {
			this.Items[i] = NewPopulatedIndex(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNodeIndex(r randyThreads, easy bool) *NodeIndex {
	this := &NodeIndex{}
	this.Id = string(randStringThreads(r))
	this.Thread = string(randStringThreads(r))
	this.Author = string(randStringThreads(r))
	this.Type = NodeIndex_Type([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	if r.Intn(10) != 0 {
		this.Date = types.NewPopulatedTimestamp(r, easy)
	}
	v3 := r.Intn(10)
	this.Parents = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.Parents[i] = string(randStringThreads(r))
	}
	this.Target = string(randStringThreads(r))
	this.Data = string(randStringThreads(r))
	this.Status = NodeIndex_Status([]int32{0, 1, 2}[r.Intn(3)])
	this.Attempts = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Attempts *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNodeIndexes(r randyThreads, easy bool) *NodeIndexes {
	this := &NodeIndexes{}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Items = make([]*NodeIndex, v4)
		for i := 0; i < v4; i++ {
			this.Items[i] = NewPopulatedNodeIndex(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRoles(r randyThreads, easy bool) *Roles {
	this := &Roles{}
	this.Default = Roles_Role([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Accounts = make(map[string]Roles_Role)
		for i := 0; i < v5; i++ {
			this.Accounts[randStringThreads(r)] = Roles_Role([]int32{0, 1, 2, 3}[r.Intn(4)])
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMember(r randyThreads, easy bool) *Member {
	this := &Member{}
	this.Id = string(randStringThreads(r))
	this.Thread = string(randStringThreads(r))
	this.Welcomed = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSchemaNode(r randyThreads, easy bool) *SchemaNode {
	this := &SchemaNode{}
	this.Name = string(randStringThreads(r))
	this.Pin = bool(bool(r.Intn(2) == 0))
	this.Plaintext = bool(bool(r.Intn(2) == 0))
	this.Mill = string(randStringThreads(r))
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Opts = make(map[string]string)
		for i := 0; i < v6; i++ {
			this.Opts[randStringThreads(r)] = randStringThreads(r)
		}
	}
	if r.Intn(10) != 0 {
		this.JsonSchema = types.NewPopulatedStruct(r, easy)
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.Links = make(map[string]*SchemaLink)
		for i := 0; i < v7; i++ {
			this.Links[randStringThreads(r)] = NewPopulatedSchemaLink(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSchemaLink(r randyThreads, easy bool) *SchemaLink {
	this := &SchemaLink{}
	this.Use = string(randStringThreads(r))
	this.Pin = bool(bool(r.Intn(2) == 0))
	this.Plaintext = bool(bool(r.Intn(2) == 0))
	this.Mill = string(randStringThreads(r))
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.Opts = make(map[string]string)
		for i := 0; i < v8; i++ {
			this.Opts[randStringThreads(r)] = randStringThreads(r)
		}
	}
	if r.Intn(10) != 0 {
		this.JsonSchema = types.NewPopulatedStruct(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNodeMessage(r randyThreads, easy bool) *NodeMessage {
	this := &NodeMessage{}
	this.Id = string(randStringThreads(r))
	this.Peer = string(randStringThreads(r))
	if r.Intn(10) != 0 {
		this.Env = pb.NewPopulatedEnvelope(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Date = types.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyThreads interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneThreads(r randyThreads) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringThreads(r randyThreads) string {
	v9 := r.Intn(100)
	tmps := make([]rune, v9)
	for i := 0; i < v9; i++ {
		tmps[i] = randUTF8RuneThreads(r)
	}
	return string(tmps)
}
func randUnrecognizedThreads(r randyThreads, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldThreads(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldThreads(dAtA []byte, r randyThreads, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateThreads(dAtA, uint64(key))
		v10 := r.Int63()
		if r.Intn(2) == 0 {
			v10 *= -1
		}
		dAtA = encodeVarintPopulateThreads(dAtA, uint64(v10))
	case 1:
		dAtA = encodeVarintPopulateThreads(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateThreads(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateThreads(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateThreads(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateThreads(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Heads)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	return n
}

func (m *Indexes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovThreads(uint64(l))
		}
	}
	return n
}

func (m *NodeIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Thread)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovThreads(uint64(m.Type))
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovThreads(uint64(l))
	}
	if len(m.Parents) > 0 {
		for _, s := range m.Parents {
			l = len(s)
			n += 1 + l + sovThreads(uint64(l))
		}
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovThreads(uint64(m.Status))
	}
	if m.Attempts != 0 {
		n += 1 + sovThreads(uint64(m.Attempts))
	}
	return n
}

func (m *NodeIndexes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovThreads(uint64(l))
		}
	}
	return n
}

func (m *Roles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Default != 0 {
		n += 1 + sovThreads(uint64(m.Default))
	}
	if len(m.Accounts) > 0 {
		for k, v := range m.Accounts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovThreads(uint64(len(k))) + 1 + sovThreads(uint64(v))
			n += mapEntrySize + 1 + sovThreads(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Thread)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Welcomed {
		n += 2
	}
	return n
}

func (m *SchemaNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Pin {
		n += 2
	}
	if m.Plaintext {
		n += 2
	}
	l = len(m.Mill)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if len(m.Opts) > 0 {
		for k, v := range m.Opts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovThreads(uint64(len(k))) + 1 + len(v) + sovThreads(uint64(len(v)))
			n += mapEntrySize + 1 + sovThreads(uint64(mapEntrySize))
		}
	}
	if m.JsonSchema != nil {
		l = m.JsonSchema.Size()
		n += 1 + l + sovThreads(uint64(l))
	}
	if len(m.Links) > 0 {
		for k, v := range m.Links {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovThreads(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovThreads(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovThreads(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SchemaLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Use)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Pin {
		n += 2
	}
	if m.Plaintext {
		n += 2
	}
	l = len(m.Mill)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if len(m.Opts) > 0 {
		for k, v := range m.Opts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovThreads(uint64(len(k))) + 1 + len(v) + sovThreads(uint64(len(v)))
			n += mapEntrySize + 1 + sovThreads(uint64(mapEntrySize))
		}
	}
	if m.JsonSchema != nil {
		l = m.JsonSchema.Size()
		n += 1 + l + sovThreads(uint64(l))
	}
	return n
}

func (m *NodeMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Env != nil {
		l = m.Env.Size()
		n += 1 + l + sovThreads(uint64(l))
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovThreads(uint64(l))
	}
	return n
}

func sovThreads(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozThreads(x uint64) (n int) {
	return sovThreads(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heads", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heads = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Indexes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Indexes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Indexes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Index{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thread", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thread = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NodeIndex_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= NodeIndex_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
			}
			m.Attempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeIndexes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeIndexes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeIndexes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NodeIndex{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Roles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Roles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Roles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			m.Default = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Default |= Roles_Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Accounts == nil {
				m.Accounts = make(map[string]Roles_Role)
			}
			var mapkey string
			var mapvalue Roles_Role
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowThreads
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= Roles_Role(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipThreads(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthThreads
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Accounts[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thread", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thread = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Welcomed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Welcomed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pin = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Plaintext = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mill", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mill = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opts == nil {
				m.Opts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowThreads
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthThreads
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthThreads
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipThreads(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthThreads
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Opts[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JsonSchema == nil {
				m.JsonSchema = &types.Struct{}
			}
			if err := m.JsonSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Links == nil {
				m.Links = make(map[string]*SchemaLink)
			}
			var mapkey string
			var mapvalue *SchemaLink
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowThreads
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthThreads
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthThreads
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SchemaLink{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipThreads(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthThreads
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Links[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Use = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pin = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plaintext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Plaintext = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mill", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mill = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opts == nil {
				m.Opts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowThreads
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthThreads
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThreads
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthThreads
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthThreads
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipThreads(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthThreads
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Opts[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JsonSchema == nil {
				m.JsonSchema = &types.Struct{}
			}
			if err := m.JsonSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = &pb.Envelope{}
			}
			if err := m.Env.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThreads
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThreads
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThreads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThreads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipThreads(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowThreads
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThreads
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthThreads
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthThreads
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowThreads
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipThreads(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthThreads
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthThreads = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowThreads   = fmt.Errorf("proto: integer overflow")
)
